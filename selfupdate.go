package selfupdate

import (
	"fmt"

	"github.com/equinox-io/equinox"
)

// public portion of signing key generated by `equinox genkey`
var publicKey = []byte(`
-----BEGIN ECDSA PUBLIC KEY-----
MHYwEAYHKoZIzj0CAQYFK4EEACIDYgAESgt7eIAY5+toKM36bGlQQwPg+jldCCje
34KIo+pR+ejJn0NArVnbIEArZ8rM9/9SZqh1v32DpiczP83ltC1Qjc0NwbT++HY9
1gxCB2UwBNubzFhAlbGGRN0N5KiUZPZ9
-----END ECDSA PUBLIC KEY-----
`)

func newYourBaseOpts() (equinox.Options, error) {
	var opts equinox.Options
	err := opts.SetPublicKeyPEM(publicKey)
	return opts, err
}

type Release struct {
	// TODO add other items as needed.
	Version string
}

func Check(appID string) (mustUpdate bool, release *Release, err error) {
	opts, err := newYourBaseOpts()
	if err != nil {
		return false, nil, err
	}
	resp, err := equinox.Check(appID, opts)
	switch {
	case err == equinox.NotAvailableErr:
		return false, &Release{Version: resp.ReleaseVersion}, nil
	case err != nil:
		return false, &Release{Version: resp.ReleaseVersion}, err
	default:
		return true, &Release{Version: resp.ReleaseVersion}, nil
	}
}

func Update(appID string) error {
	opts, err := newYourBaseOpts()
	if err != nil {
		return err
	}
	// check for the update
	resp, err := equinox.Check(appID, opts)
	switch {
	case err == equinox.NotAvailableErr:
		// No update available, already at the latest version.
		return nil
	case err != nil:
		return err
	}

	// fetch the update and apply it
	err = resp.Apply()
	if err != nil {
		return err
	}

	fmt.Printf("Updated to new version: %s!\n", resp.ReleaseVersion)
	return nil
}
